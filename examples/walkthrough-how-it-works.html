<!DOCTYPE html>
<html lang="en" style="color-scheme:dark">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Walkthrough: How the Walkthrough Skill Works</title>
<script src="https://cdn.tailwindcss.com"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
<script>
  tailwind.config = {
    theme: {
      extend: {
        colors: {
          wt: {
            bg: '#000000', surface: '#0a0a0a', raised: '#141414',
            border: '#2a2a2a', fg: '#ffffff', muted: '#a0a0a0',
            accent: '#a855f7', file: '#c084fc', red: '#ef4444',
          },
          node: {
            component: '#a855f7', composable: '#7c3aed', utility: '#6d28d9',
            external: '#525252', event: '#d8b4fe', data: '#9333ea',
          },
        },
      },
    },
  };
</script>
<style>
  .mermaid-wrap svg { max-width: none !important; height: auto !important; }
  .mermaid-wrap .node { cursor: pointer; }
  .mermaid-wrap .node:hover rect,
  .mermaid-wrap .node:hover polygon,
  .mermaid-wrap .node:hover circle,
  .mermaid-wrap .node:hover .label-container {
    filter: brightness(1.3); transition: filter .15s;
  }
  .dt-body p { color:#a0a0a0; font-size:.88rem; line-height:1.65; margin-bottom:10px; }
  .dt-body p code {
    background:rgba(168,85,247,.12); padding:1px 6px; border-radius:4px;
    font-family:'SF Mono','Fira Code',monospace; font-size:.82rem; color:#c084fc;
  }
  .dt-body .shiki {
    background: #000000 !important;
    border: 1px solid #2a2a2a;
    border-radius: 8px;
    padding: 14px 16px;
    overflow-x: auto;
    margin: 8px 0 14px;
  }
  .dt-body .shiki code {
    font-family: 'SF Mono','Fira Code',monospace;
    font-size: .78rem;
    line-height: 1.55;
    background: none;
    padding: 0;
    border-radius: 0;
    color: inherit;
  }
  .dt-body pre.code-fallback {
    background: #000000;
    border: 1px solid #2a2a2a;
    border-radius: 8px;
    padding: 14px 16px;
    overflow-x: auto;
    margin: 8px 0 14px;
  }
  .dt-body pre.code-fallback code {
    font-family: 'SF Mono','Fira Code',monospace;
    font-size: .78rem;
    line-height: 1.55;
    color: #e0e0e0;
    background: none;
    padding: 0;
    border-radius: 0;
  }
</style>
</head>
<body class="bg-wt-bg text-wt-fg m-0 overflow-hidden">
<div id="root"></div>
<script type="module">
import { createHighlighter } from 'https://cdn.jsdelivr.net/npm/shiki@3.22.0/+esm'

const { useState, useEffect, useRef, useCallback } = React;

const SUMMARY = "The walkthrough skill turns a plain-English prompt into an interactive HTML diagram of your codebase. Claude reads the skill definition, launches parallel subagents to explore relevant code, synthesizes findings into a Mermaid flowchart or ER diagram, and outputs a self-contained HTML file with pan, zoom, and clickable nodes.";

const DIAGRAM = `graph TD
  subgraph trigger["Trigger"]
    userPrompt["User Prompt"]
  end

  subgraph skill_files["Skill Configuration"]
    skillDefinition["Skill Definition"]
    htmlPatterns["HTML Patterns Reference"]
  end

  subgraph exploration["Exploration Phase"]
    scopeUnderstanding["Scope Understanding"]
    parallelExploration["Parallel Subagents"]
  end

  subgraph generation["Generation Phase"]
    synthesis["Synthesis"]
    diagramSelection["Diagram Selection"]
    htmlOutput["HTML Output"]
  end

  subgraph output["User Experience"]
    interactiveViewer["Interactive Viewer"]
  end

  userPrompt -->|"triggers"| scopeUnderstanding
  skillDefinition -->|"guides"| scopeUnderstanding
  scopeUnderstanding -->|"defines areas"| parallelExploration
  parallelExploration -->|"reports findings"| synthesis
  synthesis -->|"feeds concepts"| diagramSelection
  diagramSelection -->|"produces"| htmlOutput
  htmlPatterns -.->|"templates"| htmlOutput
  htmlOutput -->|"renders as"| interactiveViewer

  class userPrompt event
  class skillDefinition data
  class htmlPatterns data
  class scopeUnderstanding utility
  class parallelExploration composable
  class synthesis utility
  class diagramSelection utility
  class htmlOutput component
  class interactiveViewer component

  classDef component fill:#a855f7,stroke:#c084fc,color:#fff
  classDef composable fill:#7c3aed,stroke:#a78bfa,color:#fff
  classDef utility fill:#6d28d9,stroke:#8b5cf6,color:#fff
  classDef external fill:#525252,stroke:#737373,color:#fff
  classDef event fill:#d8b4fe,stroke:#e9d5ff,color:#000
  classDef data fill:#9333ea,stroke:#a855f7,color:#fff

  click userPrompt nodeClickHandler "View details"
  click skillDefinition nodeClickHandler "View details"
  click htmlPatterns nodeClickHandler "View details"
  click scopeUnderstanding nodeClickHandler "View details"
  click parallelExploration nodeClickHandler "View details"
  click synthesis nodeClickHandler "View details"
  click diagramSelection nodeClickHandler "View details"
  click htmlOutput nodeClickHandler "View details"
  click interactiveViewer nodeClickHandler "View details"
`;

const NODES = {
  userPrompt: {
    title: "User Prompt",
    description: "The natural-language request that kicks off the walkthrough. Triggers include phrases like \"walkthrough\", \"explain this flow\", \"how does X work\", or \"database schema\". The skill matches these patterns and activates automatically.",
    files: ["skills/walkthrough/skill.md:1-3"],
  },
  skillDefinition: {
    title: "Skill Definition",
    description: "The main skill file that defines the entire workflow Claude follows. It specifies the four-step process: understand scope, explore with subagents, choose diagram type, and generate HTML. Also contains the quality checklist and Mermaid conventions.",
    files: ["skills/walkthrough/skill.md"],
    code: `---
name: walkthrough
description: Generate interactive HTML walkthroughs
  with clickable Mermaid diagrams...
---`,
    lang: "markdown",
  },
  htmlPatterns: {
    title: "HTML Patterns Reference",
    description: "A complete reference for the generated HTML files. Contains the React component architecture, Mermaid configuration, Shiki setup, color palette, pan/zoom implementation, and every pattern needed to produce a working walkthrough.",
    files: ["skills/walkthrough/references/html-patterns.md"],
  },
  scopeUnderstanding: {
    title: "Scope Understanding",
    description: "Claude clarifies what the user wants explained — a feature flow, data flow, architecture overview, request lifecycle, or database schema. The goal is to frame the walkthrough as a mental model with 5-12 key concepts.",
    files: ["skills/walkthrough/skill.md:14-26"],
  },
  parallelExploration: {
    title: "Parallel Subagents",
    description: "Claude launches 2-4 Explore subagents in parallel using the Task tool. Each agent investigates one area of the codebase and returns a structured report with node IDs, labels, purposes, connections, and file paths. This keeps the main context clean.",
    files: ["skills/walkthrough/skill.md:28-84"],
    code: `// Launch parallel Explore subagents
Task(subagent_type: "Explore", prompt:
  "Explore user input handling...")
Task(subagent_type: "Explore", prompt:
  "Explore rendering pipeline...")`,
    lang: "javascript",
  },
  synthesis: {
    title: "Synthesis",
    description: "Once all subagents return, Claude combines their findings into a node list (ID, label, files, description), an edge list (connections with verb labels), and subgraph groupings. The target is 5-12 nodes total — each representing a concept, not a function.",
    files: ["skills/walkthrough/skill.md:86-94"],
  },
  diagramSelection: {
    title: "Diagram Selection",
    description: "Claude picks the right Mermaid diagram type based on the topic. Feature flows and architecture get flowcharts (graph TD/LR). Database schemas get ER diagrams. Mixed topics can use both side by side.",
    files: ["skills/walkthrough/skill.md:96-167"],
  },
  htmlOutput: {
    title: "HTML Output",
    description: "A single self-contained HTML file written to the project root. Uses React 18 (UMD), Tailwind CSS (CDN), Mermaid 11, and Shiki for syntax highlighting. No build step — everything loads from CDNs. Always dark mode with a purple accent palette.",
    files: ["skills/walkthrough/skill.md:169-209", "skills/walkthrough/references/html-patterns.md"],
  },
  interactiveViewer: {
    title: "Interactive Viewer",
    description: "The rendered walkthrough experience. Scroll to zoom toward cursor, drag to pan, auto-fit on load. Click any node to open a detail panel with a plain-English description, file paths, and optional syntax-highlighted code. Press Escape to close.",
    files: ["skills/walkthrough/references/html-patterns.md:296-379"],
  },
};

const LEGEND = [
  { label: "Component", color: "bg-node-component" },
  { label: "Composable", color: "bg-node-composable" },
  { label: "Utility", color: "bg-node-utility" },
  { label: "Event", color: "bg-node-event" },
  { label: "Data", color: "bg-node-data" },
];

// Initialize Shiki
const langs = [...new Set(Object.values(NODES).map(n => n.lang).filter(Boolean))];
if (langs.length === 0) langs.push('typescript');

let highlighter = null;
try {
  highlighter = await createHighlighter({ themes: ['vitesse-dark'], langs });
} catch (e) {
  console.warn('Shiki failed to load:', e);
}

const HIGHLIGHTED = {};
for (const [id, node] of Object.entries(NODES)) {
  if (node.code && highlighter) {
    try {
      HIGHLIGHTED[id] = highlighter.codeToHtml(node.code, {
        lang: node.lang || 'typescript',
        theme: 'vitesse-dark',
      });
    } catch (e) { console.warn(`Highlight failed for ${id}:`, e); }
  }
}

// --- React Components (createElement, no JSX) ---
const h = React.createElement;

function usePanZoom() {
  const viewportRef = useRef(null);
  const canvasRef = useRef(null);
  const zoomDisplayRef = useRef(null);
  const st = useRef({ zoom: 1, panX: 0, panY: 0 });
  const drag = useRef({ on: false, lx: 0, ly: 0 });

  const apply = useCallback(() => {
    const { zoom, panX, panY } = st.current;
    if (canvasRef.current)
      canvasRef.current.style.transform = `translate(${panX}px,${panY}px) scale(${zoom})`;
    if (zoomDisplayRef.current)
      zoomDisplayRef.current.textContent = Math.round(zoom * 100) + '%';
  }, []);

  const fitToScreen = useCallback(() => {
    const svg = canvasRef.current?.querySelector('svg');
    const vp = viewportRef.current;
    if (!svg || !vp) return;
    const s = st.current;
    const vw = vp.clientWidth, vh = vp.clientHeight;
    const sw = svg.getBoundingClientRect().width / s.zoom;
    const sh = svg.getBoundingClientRect().height / s.zoom;
    const fit = Math.max(0.15, Math.min(2, Math.min((vw - 80) / sw, (vh - 80) / sh)));
    s.zoom = fit;
    s.panX = (vw - sw * fit) / 2;
    s.panY = (vh - sh * fit) / 2;
    apply();
  }, [apply]);

  useEffect(() => {
    const vp = viewportRef.current;
    if (!vp) return;

    const onWheel = (e) => {
      e.preventDefault();
      const r = vp.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      const s = st.current;
      const f = e.deltaY < 0 ? 1.12 : 1 / 1.12;
      const nz = Math.min(4, Math.max(0.15, s.zoom * f));
      const sc = nz / s.zoom;
      s.panX = mx - sc * (mx - s.panX);
      s.panY = my - sc * (my - s.panY);
      s.zoom = nz;
      apply();
    };

    const onDown = (e) => {
      if (e.target.closest('.node')) return;
      drag.current = { on: true, lx: e.clientX, ly: e.clientY };
      vp.setPointerCapture(e.pointerId);
    };
    const onMove = (e) => {
      const d = drag.current;
      if (!d.on) return;
      st.current.panX += e.clientX - d.lx;
      st.current.panY += e.clientY - d.ly;
      d.lx = e.clientX; d.ly = e.clientY;
      apply();
    };
    const onUp = () => { drag.current.on = false; };

    vp.addEventListener('wheel', onWheel, { passive: false });
    vp.addEventListener('pointerdown', onDown);
    vp.addEventListener('pointermove', onMove);
    vp.addEventListener('pointerup', onUp);
    vp.addEventListener('pointercancel', onUp);
    window.addEventListener('resize', fitToScreen);

    return () => {
      vp.removeEventListener('wheel', onWheel);
      vp.removeEventListener('pointerdown', onDown);
      vp.removeEventListener('pointermove', onMove);
      vp.removeEventListener('pointerup', onUp);
      vp.removeEventListener('pointercancel', onUp);
      window.removeEventListener('resize', fitToScreen);
    };
  }, [apply, fitToScreen]);

  const zoomIn = useCallback(() => { st.current.zoom = Math.min(4, st.current.zoom * 1.25); apply(); }, [apply]);
  const zoomOut = useCallback(() => { st.current.zoom = Math.max(0.15, st.current.zoom / 1.25); apply(); }, [apply]);

  return { viewportRef, canvasRef, zoomDisplayRef, zoomIn, zoomOut, fitToScreen };
}

function MermaidDiagram({ onNodeClick }) {
  const ref = useRef(null);

  useEffect(() => {
    window.nodeClickHandler = onNodeClick;
    mermaid.initialize({
      startOnLoad: false,
      theme: 'dark',
      themeVariables: {
        primaryColor: '#0a0a0a',
        primaryTextColor: '#ffffff',
        primaryBorderColor: '#2a2a2a',
        lineColor: '#a0a0a0',
        secondaryColor: '#000000',
        tertiaryColor: '#000000',
        background: '#000000',
        mainBkg: '#0a0a0a',
        nodeBorder: '#2a2a2a',
        clusterBkg: 'rgba(10,10,10,0.8)',
        clusterBorder: '#7c3aed',
        titleColor: '#ffffff',
        edgeLabelBackground: 'transparent',
      },
      flowchart: { useMaxWidth: false, htmlLabels: true, curve: 'basis' },
      securityLevel: 'loose',
    });
    mermaid.render('walkthrough-diagram', DIAGRAM).then(({ svg, bindFunctions }) => {
      if (ref.current) {
        ref.current.innerHTML = svg;
        bindFunctions?.(ref.current);
      }
    });
    return () => { delete window.nodeClickHandler; };
  }, [onNodeClick]);

  return h('div', { ref, className: 'mermaid-wrap' });
}

function Summary() {
  return h('div', {
    className: 'fixed top-16 left-6 z-10 max-w-lg px-4 py-3 bg-wt-surface/80 backdrop-blur border border-wt-border rounded-lg shadow-lg pointer-events-none'
  },
    h('p', { className: 'text-sm text-wt-muted leading-relaxed' }, SUMMARY)
  );
}

function DetailPanel({ nodeId, node, onClose }) {
  useEffect(() => {
    const onKey = (e) => { if (e.key === 'Escape') onClose(); };
    document.addEventListener('keydown', onKey);
    return () => document.removeEventListener('keydown', onKey);
  }, [onClose]);

  const codeHtml = HIGHLIGHTED[nodeId];

  return h('div', {
    className: 'fixed top-4 right-4 bottom-4 w-[560px] z-30 bg-wt-surface border border-wt-border rounded-xl shadow-2xl flex flex-col overflow-hidden'
  },
    h('button', {
      onClick: onClose,
      className: 'absolute top-3 right-3 z-10 w-7 h-7 rounded-md border border-wt-border bg-wt-raised text-wt-muted flex items-center justify-center text-lg hover:bg-wt-red hover:border-wt-red hover:text-white transition-colors'
    }, '\u00d7'),
    h('div', { className: 'flex-1 overflow-y-auto p-5' },
      h('h2', { className: 'text-lg font-bold text-wt-fg mb-3 pr-9' }, node.title),
      h('div', { className: 'dt-body' },
        h('p', null, node.description)
      ),
      node.code ? h('div', { className: 'dt-body' },
        codeHtml
          ? h('div', { dangerouslySetInnerHTML: { __html: codeHtml } })
          : h('pre', { className: 'code-fallback' }, h('code', null, node.code))
      ) : null,
      node.files && node.files.length > 0 ? h('div', { className: 'mt-4 pt-3 border-t border-wt-border' },
        h('div', { className: 'text-[0.7rem] uppercase tracking-wider text-wt-muted font-semibold mb-1.5' }, 'Files'),
        h('code', { className: 'text-sm text-wt-file font-mono leading-relaxed' },
          node.files.map((f, i) => h('span', { key: i }, f, h('br')))
        )
      ) : null
    )
  );
}

function ZoomControls({ zoomDisplayRef, onZoomIn, onZoomOut, onFit }) {
  return h('div', { className: 'fixed bottom-5 left-5 z-20 flex items-center gap-1 bg-wt-surface border border-wt-border rounded-lg shadow-xl overflow-hidden' },
    h('button', { onClick: onZoomOut, className: 'px-2.5 py-1.5 text-wt-muted hover:text-wt-fg hover:bg-wt-raised transition-colors text-sm' }, '\u2212'),
    h('span', { ref: zoomDisplayRef, className: 'px-2 py-1.5 text-xs text-wt-muted min-w-[3rem] text-center' }, '100%'),
    h('button', { onClick: onZoomIn, className: 'px-2.5 py-1.5 text-wt-muted hover:text-wt-fg hover:bg-wt-raised transition-colors text-sm' }, '+'),
    h('button', { onClick: onFit, className: 'px-2.5 py-1.5 text-wt-muted hover:text-wt-fg hover:bg-wt-raised transition-colors text-xs border-l border-wt-border' }, 'Fit')
  );
}

function App() {
  const [activeId, _setActiveId] = useState(null);
  const pz = usePanZoom();

  const setActiveNode = useCallback((nodeId) => {
    _setActiveId(nodeId);
    document.querySelectorAll('.mermaid-wrap .node').forEach(n => { n.style.opacity = nodeId ? '0.4' : '1'; });
    if (nodeId) {
      const el = document.querySelector(`.mermaid-wrap .node[id*="${nodeId}"]`);
      if (el) el.style.opacity = '1';
    }
  }, []);

  const closeDetail = useCallback(() => {
    _setActiveId(null);
    document.querySelectorAll('.mermaid-wrap .node').forEach(n => { n.style.opacity = '1'; });
  }, []);

  useEffect(() => { setTimeout(pz.fitToScreen, 600); }, [pz.fitToScreen]);

  return h(React.Fragment, null,
    h('header', { className: 'fixed top-0 inset-x-0 z-10 px-6 py-3.5 bg-gradient-to-b from-wt-bg to-transparent pointer-events-none' },
      h('h1', { className: 'text-base font-semibold text-wt-fg' }, 'How the Walkthrough Skill Works'),
      h('p', { className: 'text-sm text-wt-muted mt-0.5' }, 'From user prompt to interactive diagram — the full pipeline')
    ),
    h(Summary),
    h('div', { ref: pz.viewportRef, className: 'w-full h-screen overflow-hidden cursor-grab active:cursor-grabbing' },
      h('div', { ref: pz.canvasRef, className: 'origin-top-left will-change-transform inline-block p-[80px_60px_60px]' },
        h(MermaidDiagram, { onNodeClick: setActiveNode })
      )
    ),
    h(ZoomControls, { zoomDisplayRef: pz.zoomDisplayRef, onZoomIn: pz.zoomIn, onZoomOut: pz.zoomOut, onFit: pz.fitToScreen }),
    h('div', { className: 'fixed bottom-5 left-1/2 -translate-x-1/2 z-20 flex gap-4 px-4 py-2 bg-wt-surface border border-wt-border rounded-lg shadow-xl' },
      LEGEND.map(l =>
        h('span', { key: l.label, className: 'flex items-center gap-1.5 text-xs text-wt-muted' },
          h('span', { className: `w-2 h-2 rounded-full ${l.color}` }),
          l.label
        )
      )
    ),
    activeId && NODES[activeId] ? h(DetailPanel, { nodeId: activeId, node: NODES[activeId], onClose: closeDetail }) : null,
    h('div', { className: 'fixed bottom-5 right-5 z-20 text-xs text-wt-muted opacity-50' },
      h('kbd', null, 'Scroll'), ' zoom \u00b7 ', h('kbd', null, 'Drag'), ' pan \u00b7 Click nodes'
    )
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(h(App));
</script>
</body>
</html>
